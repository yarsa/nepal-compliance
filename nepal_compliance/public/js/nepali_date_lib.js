"use strict"; var NepaliDateLib = (() => { var _ = Object.defineProperty; var Z = Object.getOwnPropertyDescriptor; var v = Object.getOwnPropertyNames; var t3 = Object.prototype.hasOwnProperty; var e3 = (r, t) => { for (var e in t) _(r, e, { get: t[e], enumerable: !0 }) }, r3 = (r, t, e, o) => { if (t && typeof t == "object" || typeof t == "function") for (let n of v(t)) !t3.call(r, n) && n !== e && _(r, n, { get: () => t[n], enumerable: !(o = Z(t, n)) || o.enumerable }); return r }; var n3 = r => r3(_({}, "__esModule", { value: !0 }), r); var p3 = {}; e3(p3, { ALLOWED_FORMATS: () => i3, BS_MONTHS_WITH_AD: () => H, CALENDARS: () => u3, FORMAT_TOKENS: () => C, LOCALE: () => m3, MONTH_NAMES_EN_AD: () => K, MONTH_NAMES_EN_BS: () => P, MONTH_NAMES_NE_BS: () => I, MONTH_SHORT_EN_AD: () => x, MONTH_SHORT_NE_BS: () => J, NepaliCalendar: () => $, NepaliDate: () => D, REF_AD: () => B, REF_BS: () => N, WEEKDAY_NAMES_EN: () => X, WEEKDAY_NAMES_NE: () => c3, WEEKDAY_SHORT_EN: () => j, WEEKDAY_SHORT_NE: () => D3, adToBs: () => f, bsToAd: () => O, formatDateAD: () => L, formatDateBS: () => F, formatNumber: () => y, getDaysInMonth: () => a3, getDaysInYear: () => o3, getMonthLength: () => k, nepaliDigits: () => R, padNumber: () => w, parseBS: () => M3, validateDate: () => A }); var c = { 1970: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1971: [31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30], 1972: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 1973: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 1974: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1975: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 1976: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 1977: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 1978: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1979: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 1980: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 1981: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 1982: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1983: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 1984: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 1985: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 1986: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1987: [31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30], 1988: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 1989: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 1990: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1991: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 1992: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 1993: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1994: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1995: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 1996: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 1997: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1998: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 1999: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2e3: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2001: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2002: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2003: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2004: [30, 32, 31, 32, 31, 30, 30, 30, 30, 29, 29, 31], 2005: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2006: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2007: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2008: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31], 2009: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2010: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2011: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2012: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 2013: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2014: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2015: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2016: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 2017: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2018: [31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2019: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2020: [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30], 2021: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2022: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 2023: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2024: [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30], 2025: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2026: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2027: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2028: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2029: [31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30], 2030: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2031: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2032: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2033: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2034: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2035: [30, 32, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31], 2036: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2037: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2038: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2039: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 2040: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2041: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2042: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2043: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 2044: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2045: [31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2046: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2047: [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30], 2048: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2049: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 2050: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2051: [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30], 2052: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2053: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 2054: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2055: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2056: [31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30], 2057: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2058: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2059: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2060: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2061: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2062: [31, 31, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31], 2063: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2064: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2065: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2066: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31], 2067: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2068: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2069: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2070: [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30], 2071: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2072: [31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30], 2073: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31], 2074: [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30], 2075: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2076: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 2077: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2078: [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30], 2079: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2080: [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30], 2081: [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31], 2082: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2083: [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30], 2084: [31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30], 2085: [31, 32, 31, 32, 30, 31, 30, 30, 29, 30, 30, 30], 2086: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30], 2087: [31, 31, 32, 31, 31, 31, 30, 30, 30, 30, 30, 30], 2088: [30, 31, 32, 32, 30, 31, 30, 30, 29, 30, 30, 30], 2089: [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30] }, E = Object.keys(c).map(Number), M = Math.min(...E), p = Math.max(...E); function k(r, t) { let e = c[r]; if (!e) throw new Error(`Year ${r} not found in BS_MONTH_DAYS`); if (t < 0 || t > 11) throw new Error(`Invalid monthIndex: ${t}`); return e[t] } function A(r, t, e) { if (t < 0 || t > 11) throw new Error(`Invalid monthIndex: ${t}`); let o = k(r, t); if (e < 1 || e > o) throw new Error(`Invalid day: ${e} for ${r}-${t}`) } var N = { year: 1970, monthIndex: 0, day: 1 }, B = new Date(Date.UTC(1913, 3, 13)), S = new Map, U = 0; for (let r = M; r <= p; r++)S.set(r, U), U += c[r].reduce((t, e) => t + e, 0); var W = new Map; for (let r = M; r <= p; r++) { let t = [0], e = 0; for (let o = 0; o < 12; o++)e += c[r][o], t.push(e); W.set(r, t) } function O(r, t, e) { A(r, t, e); let o = s3(r, t, e), n = new Date(B); return n.setUTCDate(n.getUTCDate() + o), n } function f(r) { let e = Math.floor((r.getTime() - B.getTime()) / 864e5), o = N.year, n = M, i = p; for (; n <= i;) { let m = Math.floor((n + i) / 2), Y = (S.get(m) || 0) - (S.get(N.year) || 0), l = c[m]?.reduce((b, T) => b + T, 0) || 0; if (e >= Y && e < Y + l) { o = m; break } else e < Y ? i = m - 1 : n = m + 1 } let a = e - ((S.get(o) || 0) - (S.get(N.year) || 0)), s = W.get(o) || [], u = 0; for (let m = 0; m < 12; m++)if (a >= s[m] && a < s[m + 1]) { u = m; break } let h = a - s[u] + 1; return { year: o, monthIndex: u, day: h } } function o3(r) { return c[r]?.reduce((t, e) => t + e, 0) || 0 } function a3(r, t) { return c[r]?.[t] || 0 } function s3(r, t, e) { let o = 0; for (let n = N.year; n < r; n++)o += c[n].reduce((i, a) => i + a, 0); for (let n = 0; n < t; n++)o += c[r][n]; return o += e - 1, o } var i3 = ["YYYY-MM-DD", "YYYY/MM/DD", "YYYY.MM.DD", "YYYY-M-D", "YYYY/M/D", "YYYY.M.D", "DD-MM-YYYY", "DD/MM/YYYY", "DD.MM.YYYY", "D-M-YYYY", "D/M/YYYY", "D.M.YYYY", "MMMM D, YYYY", "MMMM DD, YYYY", "D MMMM, YYYY", "DD MMMM, YYYY", "MMM D, YYYY", "MMM DD, YYYY", "D MMM, YYYY", "DD MMM, YYYY"], C = { YYYY: "Full year (e.g., 2079 or 2022)", MM: "Month as 2-digit number, 01-12", M: "Month as number, 1-12", MMMM: "Full month name", MMM: "Short month name", DD: "Day of month as 2-digit, 01-31", D: "Day of month as number, 1-31", dddd: "Full weekday name (AD only)", ddd: "Short weekday name (AD only)" }, u3 = ["BS", "AD"], m3 = ["en", "ne"], R = ["\u0966", "\u0967", "\u0968", "\u0969", "\u096A", "\u096B", "\u096C", "\u096D", "\u096E", "\u096F"], P = ["Baishakh", "Jestha", "Ashadh", "Shrawan", "Bhadra", "Ashwin", "Kartik", "Mangsir", "Poush", "Magh", "Falgun", "Chaitra"], I = ["\u092C\u0948\u0936\u093E\u0916", "\u091C\u0947\u0937\u094D\u0920", "\u0906\u0937\u093E\u0922", "\u0936\u094D\u0930\u093E\u0935\u0923", "\u092D\u093E\u0926\u094D\u0930", "\u0906\u0936\u094D\u0935\u093F\u0928", "\u0915\u093E\u0930\u094D\u0924\u093F\u0915", "\u092E\u0902\u0938\u093F\u0930", "\u092A\u094C\u0937", "\u092E\u093E\u0918", "\u092B\u093E\u0932\u094D\u0917\u0941\u0928", "\u091A\u0948\u0924\u094D\u0930"], J = ["\u092C\u0948", "\u091C\u0947", "\u0906", "\u0936\u094D\u0930", "\u092D\u093E", "\u0906", "\u0915\u093E", "\u092E\u0902", "\u092A\u094C", "\u092E", "\u092B\u093E", "\u091A\u0948"], K = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], x = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], X = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], j = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], c3 = ["\u0906\u0907\u0924\u0935\u093E\u0930", "\u0938\u094B\u092E\u0935\u093E\u0930", "\u092E\u0902\u0917\u0932\u0935\u093E\u0930", "\u092C\u0941\u0927\u0935\u093E\u0930", "\u092C\u093F\u0939\u093F\u0935\u093E\u0930", "\u0936\u0941\u0915\u094D\u0930\u0935\u093E\u0930", "\u0936\u0928\u093F\u0935\u093E\u0930"], D3 = ["\u0906\u0907\u0924", "\u0938\u094B\u092E", "\u092E\u0902\u0917\u0932", "\u092C\u0941\u0927", "\u092C\u093F\u0939\u093F", "\u0936\u0941\u0915\u094D\u0930", "\u0936\u0928\u093F"], h3 = [[3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 0], [0, 1], [1, 2], [2, 3]], H = P.map((r, t) => { let [e, o] = h3[t], n = `${x[e]}/${x[o]}`; return { en: r, np: I[t], ad: n } }); function w(r, t = "en") { let e = r.toString().padStart(2, "0"); return t === "ne" ? e.replace(/\d/g, o => R[Number(o)]) : e } function y(r, t = "en") { return t === "ne" ? String(r).replace(/\d/g, e => R[Number(e)]) : String(r) } function G(r, t) { let e = Object.keys(t).sort((n, i) => i.length - n.length), o = new RegExp(e.map(n => n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|"), "g"); return r.replace(o, n => t[n]) } function F(r, t = "YYYY-MM-DD", e = "en") { let n = { YYYY: y(r.year, e), MM: w(r.monthIndex + 1, e), M: y(r.monthIndex + 1, e), DD: w(r.day, e), D: y(r.day, e), MMMM: I[r.monthIndex], MMM: J[r.monthIndex] }; return G(t, n) } function L(r, t = "YYYY-MM-DD", e = "en") { let o = y(r.getFullYear(), e), n = r.getMonth(), i = r.getDate(), a = r.getDay(), s = { YYYY: o, MM: w(n + 1, e), M: y(n + 1, e), DD: w(i, e), D: y(i, e), dddd: X[a], ddd: j[a], MMMM: K[n], MMM: x[n] }; return G(t, s) } var D = class r { constructor(t, e, o, n = 0, i = 0, a = 0) { this.hour = 0; this.minute = 0; this.second = 0; if (t == null || e == null || o == null) { let s = new Date, u = f(s); this.year = u.year, this.monthIndex = u.monthIndex, this.day = u.day, this.hour = s.getHours(), this.minute = s.getMinutes(), this.second = s.getSeconds() } else A(t, e, o), this.year = t, this.monthIndex = e, this.day = o, this.hour = n, this.minute = i, this.second = a } static fromBS(t) { if (!t) return new r; let e = r.parse(t, "BS"); return new r(e.year, e.monthIndex, e.day, e.hour, e.minute, e.second) } static fromAD(t) { let e; function o(n, i) { let a = i === "local", s = f(n); return new r(s.year, s.monthIndex, s.day, a ? n.getHours() : n.getUTCHours(), a ? n.getMinutes() : n.getUTCMinutes(), a ? n.getSeconds() : n.getUTCSeconds()) } if (!t) e = new Date; else if (t instanceof Date) e = t; else if (t instanceof r) e = t.toAD(); else if (typeof t == "string") e = r.parse(t, "AD").toAD(); else { if (typeof t == "number") return o(new Date(t), "local"); Array.isArray(t) ? e = new Date(t[0], t[1], t[2]) : e = r.parse(t, "AD").toAD() } return o(e, "UTC") } static parse(t, e = "BS") { if (!t) return r.fromBS(); if (t instanceof r) return t.clone(); if (t instanceof Date) { let { year: o, monthIndex: n, day: i } = f(t); return new r(o, n, i, t.getHours(), t.getMinutes(), t.getSeconds()) } if (typeof t == "number") { let o = new Date(t), { year: n, monthIndex: i, day: a } = f(o); return new r(n, i, a, o.getHours(), o.getMinutes(), o.getSeconds()) } if (Array.isArray(t)) { let [o, n, i] = t; if (e === "BS") return new r(o, n, i); let { year: a, monthIndex: s, day: u } = f(new Date(o, n, i)); return new r(a, s, u) } if (typeof t == "string") { let [o, n] = t.trim().split(" "), a = o.replace(/\//g, "-").split("-").map(g => parseInt(g, 10)); if (a.length !== 3 || a.some(isNaN)) throw new Error(`Invalid date string: ${t}`); let s = a[0] > 31, u, h, m; s ? [u, h, m] = [a[0], a[1] - 1, a[2]] : [m, h, u] = [a[0], a[1] - 1, a[2]]; let Y = 0, l = 0, b = 0; if (n) { let g = n.split(":").map(V => parseInt(V, 10)); Y = g[0] ?? 0, l = g[1] ?? 0, b = g[2] ?? 0 } let T = new Date(Date.UTC(u, h, m, Y, l, b)); if (e === "BS") return new r(u, h, m, Y, l, b); let { year: z, monthIndex: q, day: Q } = f(T); return new r(z, q, Q, Y, l, b) } throw new Error(`Unsupported value for NepaliDate.parse: ${t}`) } toAD() { let t = O(this.year, this.monthIndex, this.day); return t.setUTCHours(this.hour, this.minute, this.second, 0), t } before(t) { return this.toAD() < t.toAD() } after(t) { return this.toAD() > t.toAD() } equals(t) { return this.year === t.year && this.monthIndex === t.monthIndex && this.day === t.day && this.hour === t.hour && this.minute === t.minute && this.second === t.second } format(t) { let { format: e = "YYYY-MM-DD", calendar: o = "BS", locale: n = "en", withTime: i = !1 } = t ?? {}, a = h => h.toString().padStart(2, "0"), s = i && !!(this.hour || this.minute || this.second), u; return o === "BS" ? u = F(this, e, n) : u = L(this.toAD(), e, n), s && (u += ` ${a(this.hour)}:${a(this.minute)}:${a(this.second)}`), u } static getFormatTokens() { return C } clone() { return new r(this.year, this.monthIndex, this.day, this.hour, this.minute, this.second) } }; var d = class d { constructor(t) { this.monthCache = {}; if (!c[t]) throw new Error(`Year ${t} out of range (${M}-${p})`); this.year = t } getMonth(t) { if (t < 0 || t > 11) throw new Error(`Invalid month index: ${t} (expected 0-11)`); if (this.monthCache[t]) return this.monthCache[t]; let e = c[this.year][t], n = new D(this.year, t, 1).toAD().getDay(), i = []; for (let s = 0; s < n; s++)i.push(null); for (let s = 1; s <= e; s++) { let u = new D(this.year, t, s), h = u.toAD(); i.push({ en: s, ad: h.getDate(), np: y(s, "ne"), date: u }) } let a = { month: H[t], days: i }; return this.monthCache[t] = a, a } getAllMonths() { return Array.from({ length: 12 }, (t, e) => this.getMonth(e)) } getMonthAdYear(t) { let o = this.getMonth(t).days.find(n => n !== null); return o ? o.date.toAD().getFullYear() : this.year } getCurrentMonth() { let t = D.fromAD(); return t.year === this.year ? this.getMonth(t.monthIndex) : null } isCurrentYear() { return D.fromAD().year === this.year } nextYear() { if (this.year >= p) throw new Error(`Cannot go beyond year ${p}`); return new d(this.year + 1) } prevYear() { if (this.year <= M) throw new Error(`Cannot go before year ${M}`); return new d(this.year - 1) } canGoNext() { return this.year < p } canGoPrev() { return this.year > M } clearCache() { this.monthCache = {} } static current() { let t = D.fromAD(); return new d(t.year) } static fromDate(t) { return new d(t.year) } }; d.minYear = M, d.maxYear = p, d.years = E; var $ = d; function M3(r) { let [t, e, o] = r.split("-").map(Number); return new D(t, e, o) } return n3(p3); })();
